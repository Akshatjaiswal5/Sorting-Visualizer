<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
 <script>
	 function dis() 
{
document.getElementById('insertionFunction').style.pointerEvents="none";
document.getElementById('insertionFunction').style.cursor="default";
document.getElementById('deletionFunction').style.pointerEvents="none";
document.getElementById('deletionFunction').style.cursor="default";
document.getElementById('emptyBinarySearchTreeButton').style.pointerEvents="none";
document.getElementById('emptyBinarySearchTreeButton').style.cursor="default";
}
function ena()
{
document.getElementById('insertionFunction').style.pointerEvents="auto";
document.getElementById('insertionFunction').style.cursor="pointer";
document.getElementById('deletionFunction').style.pointerEvents="auto";
document.getElementById('deletionFunction').style.cursor="pointer";
document.getElementById('emptyBinarySearchTreeButton').style.pointerEvents="auto";
document.getElementById('emptyBinarySearchTreeButton').style.cursor="pointer";
}


function hideArea()
{

}

function deleteModal()
{
$('#heading').html("BINARY SEARCH TREE");
$("#tc").html("");
$.trim($("#removeValue").val(''));
}

function insertModal()
{
$('#heading').html("BINARY SEARCH TREE");
$("#tc").html("");
$.trim($("#binaryTreeValue").val(''));
}
function showBinaryTree()
	{
		document.getElementById('home').style.visibility = 'hidden';
		document.getElementById('binaryTree').style.visibility = 'visible';
	}
function Node(data, element)
	{
		this.data = data;
		this.element = element;
		this.leftLine = null;
		this.rightLine = null;
		this.left = null;
		this.right = null;
	}
	function NodeQueueObject(node)
	{
		this.node = node;
		this.line = null;
		this.message = '';
	}
	var highlightNodeQueue = [];
	var newElement = null;
	var newLine = null;
	var newNumber;
	var bCounter = 0;
	var binarySearchTreeRoot = null;
	function insertToBinarySearchTree()
	{
		$('#heading').html("INSERTION");
		$("#tc").html("TIME COMPLEXITY: O(h)");
		newElement = null;
		newLine = null;
		window.scrollTo(0, 0);
		var error;
		var number = document.getElementById('binaryTreeValue').value;
		if(number.length == 0 || number == '')
		{
			alert("Invalid Input");
			error = "Invalid input";
			document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = error;
			return;
		}
		if(isNaN(number))
		{
			alert("Invalid Input");
			error = "Invalid input";
			document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = error;
			return;
		}
		else
		{
			number = parseInt(number);
			document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = '';
		}
		dis();
		var length = 640;
		var distance = 640;
		var height = 0;
		var newNode, node;
		if(binarySearchTreeRoot == null)
		{
			var div = document.createElement('div');
			div.id = 'binarySearchTreeNode' + bCounter;
			div.className = 'binarySearchTreeNodeClass' + bCounter;
			var label = document.createElement('label');
			label.innerHTML = number;
			label.style = 'line-height: 34px;';
			div.append(label);
			div.style = 'min-width: 50px; height: 50px; border: 3px solid black; position: absolute; top: 20px; text-align: center; background: #bfbfbf;border-radius: 50%; transition-property: transform;transform: translate(' + length + 'px, ' + (height * 80) + 'px);';
			div.classList.add('highlightNode');
			div.addEventListener('animationend', function() {
				// alert('afF');
				div.removeEventListener('animationend', this);
				// alert('afF1');
				div.classList.remove('highlightNode');
				// alert('uu');
			});
			bCounter++;
			// document.getElementById('binarySearchTreeView').append(div);
			newElement = div;
			newNumber = number;
			newNode = new Node(number, div);
			binarySearchTreeRoot = newNode;
		}
		else
		{
			node = binarySearchTreeRoot;
			while(true)
			{
				// node.element.classList.add('highlightNode');
				// var j = false;
				// node.element.addEventListener('animationend', function() {
					// node.element.classList.remove('highlightNode');
				// 	// alert('Done');
				// 	// alert('j = ' + j);
				// 	j = true;
				// 	// alert('j = ' + j);
				// });
					// for(;true;) {
					// 	alert('OK ' + j);
					// 	if(j) break;
					// }
				var nodeQueueObject = new NodeQueueObject(node.element);
				if(number == node.data)
				{
					alert(number + ' is already present');
					nodeQueueObject.message = number + ' is already present';
					highlightNodeQueue.push(nodeQueueObject);
					break;
				}
				if(height == 5)
				{
					alert('Height should be less than 6');
					nodeQueueObject.message = 'Height should be less than 6';
					highlightNodeQueue.push(nodeQueueObject);
					break;
				}
				if(number < node.data)
				{
					distance /= 2;
					length -= distance;
					height++;
					if(node.left == null)
					{
						var div = document.createElement('div');
						div.id = 'binarySearchTreeNode' + bCounter;
						div.className = 'binarySearchTreeNodeClass' + bCounter;
						var label = document.createElement('label');
						label.innerHTML = number;
						label.style = 'line-height: 34px;';
						div.append(label);
						div.style = 'min-width: 50px; height: 50px; border: 3px solid black; position: absolute; top: 20px; text-align: center; background: #bfbfbf;border-radius: 50%; transition-property: transform;transform: translate(' + length + 'px, ' + (height * 80) + 'px);';
						div.classList.add('highlightNode');
						div.addEventListener('animationend', function() {
							div.classList.remove('highlightNode');
						});
						var line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
						line.id = 'binarySearchTreeLine' + bCounter;
						line.className = 'binarySearchTreeLineClass' + bCounter;
						// canvas.setAttribute('width', distance - 40 + 15 + ((height - 0) * 3));
						// canvas.setAttribute('height', 40 + 18 + 13 - ((height - 1) * 2));
						// canvas.style = 'position: absolute; transform: translate(' + (length  + 40 - 10 - ((height - 0) * 2)) + 'px, ' + ((height * 80) - 40 - 13 + ((height - 1) * 1)) + 'px);';
						line.style = 'stroke: black; stroke-width: 3; stroke-dasharray: 500;';
						line.classList.add('animateLine');
						// var ctx = canvas.getContext("2d");
						// ctx.beginPath();
						// ctx.moveTo(distance - 40 + 15 + ((height - 0) * 3), 0);
						var x1 = length + distance + 20;
						var y1 = (height * 80) - 80 + 20;
						var x2 = length + 20;
						var y2 = (height * 80) + 20;
						// line.setAttribute('x1', x1);
						// line.setAttribute('y1', y1);
						// line.setAttribute('x2', x2);
						// line.setAttribute('y2', y2);
						line.setAttribute('d', 'M' + x1 + ' ' + y1 + ' L' + x2 + ' ' + y2);
						// ctx.lineTo(0, 40 + 18 + 13 + ((height - 1) * 2));
						// ctx.strokeStyle = 'black';
						// ctx.lineWidth = 3;
						// ctx.stroke();
						bCounter++;
						// document.getElementById('binarySearchTreeView').append(canvas);
						// document.getElementById('binarySearchTreeView').append(div);
						newElement = div;
						newLine = line;
						newNumber = number;
						nodeQueueObject.message = number + ' is less than ' + node.data + ', so go left';
						highlightNodeQueue.push(nodeQueueObject);
						newNode = new Node(number, div);
						node.left = newNode;
						node.leftLine = line;
						break;
					}
					else
					{
						nodeQueueObject.line = node.leftLine;
						nodeQueueObject.message = number + ' is less than ' + node.data + ', so go left';
						highlightNodeQueue.push(nodeQueueObject);
						node = node.left;
					}
				}
				else
				{
					distance /= 2;
					length += distance;
					height++;
					if(node.right == null)
					{
						var div = document.createElement('div');
						div.id = 'binarySearchTreeNode' + bCounter;
						div.className = 'binarySearchTreeNodeClass' + bCounter;
						var label = document.createElement('label');
						label.innerHTML = number;
						label.style = 'line-height: 34px;';
						div.append(label);
						div.style = 'min-width: 50px; height: 50px; border: 3px solid black; position: absolute; top: 20px; text-align: center; background: #bfbfbf; border-radius: 50%; transition-property: transform;transform: translate(' + length + 'px, ' + (height * 80) + 'px);';
						div.classList.add('highlightNode');
						div.addEventListener('animationend', function() {
							div.classList.remove('highlightNode');
						});
						// <line x1 = '0' y1 = '0' x2 = '200' y2 = '200' style = 'stroke:rgb(255,0,0);stroke-width:2' />
						var line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
						line.id = 'binarySearchTreeLine' + bCounter;
						line.className = 'binarySearchTreeLineClass' + bCounter;
						// line.setAttribute('width', distance - 40 + 15 + ((height - 0) * 3));
						// line.setAttribute('height', 40 + 18 + 13 - ((height - 1) * 2));
						// canvas.style = 'position: absolute; transform: translate(' + (length  + 40 - 2 - ((height - 0) * 2) - distance) + 'px, ' + ((height * 80) - 40 - 13 + ((height - 1) * 1)) + 'px);';
						line.style = 'stroke: black; stroke-width: 3; stroke-dasharray: 500;';
						line.classList.add('animateLine');
						// var ctx = canvas.getContext("2d");
						// ctx.beginPath();
						// ctx.moveTo(0, 0);
						var x1 = length - distance + 20;
						var y1 = (height * 80) - 80 + 20;
						var x2 = length + 20;
						var y2 = (height * 80) + 20;
						// line.setAttribute('x1', x1);
						// line.setAttribute('y1', y1);
						// line.setAttribute('x2', x2);
						// line.setAttribute('y2', y2);
						line.setAttribute('d', 'M' + x1 + ' ' + y1 + ' L' + x2 + ' ' + y2);
						// ctx.lineTo(distance - 40 + 15 + ((height - 0) * 3), 40 + 18 + 13 + ((height - 1) * 2));
						// ctx.strokeStyle = 'black';
						// ctx.lineWidth = 3;
						// ctx.stroke();
						bCounter++;
						// document.getElementById('binarySearchTreeView').append(canvas);
						// document.getElementById('binarySearchTreeView').append(div);
						newElement = div;
						newLine = line;
						newNumber = number;
						nodeQueueObject.message = number + ' is greater than ' + node.data + ', so go right';
						highlightNodeQueue.push(nodeQueueObject);
						newNode = new Node(number, div);
						node.right = newNode;
						node.rightLine = line;
						break;
					}
					else
					{
						nodeQueueObject.line = node.rightLine;
						nodeQueueObject.message = number + ' is greater than ' + node.data + ', so go right';
						highlightNodeQueue.push(nodeQueueObject);
						node = node.right;
					}
				}
			}
		}
		highlightForInsertion();
	}
	/*function disableInputFields()
	{
		document.getElementById('binarySearchTreeToHome').disabled = true;
		document.getElementById('binaryTreeValue').disabled = true;
		document.getElementById('insertToBinarySearchTreeButton').disabled = true;
		document.getElementById('removeValue').disabled = true;
		document.getElementById('removeFromBinarySearchTreeButton').disabled = true;
		document.getElementById('emptyBinarySearchTreeButton').disabled = true;
	}
	function enableInputFields()
	{
		document.getElementById('binarySearchTreeToHome').disabled = false;
		document.getElementById('binaryTreeValue').disabled = false;
		document.getElementById('insertToBinarySearchTreeButton').disabled = false;
		document.getElementById('removeValue').disabled = false;
		document.getElementById('removeFromBinarySearchTreeButton').disabled = false;
		document.getElementById('emptyBinarySearchTreeButton').disabled = false;
	}*/
	var g = false;
	function highlightForInsertion()
	{
		if(g)
		{
			// alert("** " + nodeQueue[0],node + " ** " + nodeQueue.length);
			highlightNodeQueue[0].node.removeEventListener('animationend', highlightForInsertion);
			highlightNodeQueue[0].node.classList.remove('highlightNode');
			if(highlightNodeQueue[0].line != null) highlightNodeQueue[0].line.classList.remove('highlightLine');
			highlightNodeQueue.splice(0, 1);
		}
		g = true;
		if(highlightNodeQueue.length == 0)
		{	
			if(newLine != null)
			{
				document.getElementById('svg').append(newLine);
				newLine.addEventListener('animationend', showNode, false);
			}
			else
			{
				showNode();
			}
			g = false;
			return;
		}
		// alert(nodeQueue[0].node.classList);
		highlightNodeQueue[0].node.classList.add('highlightNode');
		if(highlightNodeQueue[0].line != null) highlightNodeQueue[0].line.classList.add('highlightLine');
		document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = highlightNodeQueue[0].message;
		// alert(nodeQueue[0].node.classList);
		highlightNodeQueue[0].node.addEventListener('animationend', highlightForInsertion, false);
	}
	function showNode()
	{
		if(newLine != null) newLine.removeEventListener('animationend', showNode);
		if(newLine != null) newLine.classList.remove('animateLine');
		if(newElement != null) document.getElementById('binarySearchTreeView').append(newElement);
		if(newElement != null) document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = newNumber + ' is inserted';
		newElement = null;
		newLine = null;
		//
ena();
	}

	function AnimateNodeQueueObject(node)
	{
		this.node = node;
		this.oldDistance = 0;
		this.newDistance = 0;
		this.oldX = 0;
		this.oldY = 0;
		this.newX = 0;
		this.newY = 0;
	}
	function AnimateLineQueueObject(line, animate)
	{
		this.line = line;
		this.animate = animate;
		this.oldx1 = 0;
		this.oldy1 = 0;
		this.oldx2 = 0;
		this.oldy2 = 0;
		this.newx1 = 0;
		this.newy2 = 0;
		this.newx2 = 0;
		this.newy2 = 0;
	}
	var removeLine = null;
	var removeNode = null;
	var animateNodeQueue = [];
	var animateLineQueue = [];





	function removeFromBinarySearchTree()
	{
		$('#heading').html("DELETION");
		$("#tc").html("TIME COMPLEXITY: O(h)");
		window.scrollTo(0, 0);
		var error;
		var number = document.getElementById('removeValue').value;
		if(number.length == 0 || number == '')
		{
			alert("Invalid Input");
			error = "Invalid input";
			document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = error;
			return;
		}
		if(isNaN(number))
		{
			alert("Invalid Input");
			error = "Invalid input";
			document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = error;
			return;
		}
		else
		{
			number = parseInt(number);
			document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = '';
		}
		removeLine = null;
		removeNode = null;
		dis();
		var length = 640;
		var distance = 640;
		var height = 0;
		var newNode, node;
		var found = 0;
		var t = binarySearchTreeRoot;
		var j;
		while(t != null)
		{
			var nodeQueueObject = new NodeQueueObject(t.element);
			if(t.data == number)
			{
				nodeQueueObject.message = '';
				highlightNodeQueue.push(nodeQueueObject);
				break;
			}
			j = t;
			if(number < t.data)
			{
				distance /= 2;
				length -= distance;
				height++;
				if(t.left != null) nodeQueueObject.line = t.leftLine;
				if(t.left != null) nodeQueueObject.message = number + ' is less than ' + t.data + ', so go left';
document.getElementById('removeFromBinaryTreeErrorSection').innerHTML =nodeQueueObject.message;
				highlightNodeQueue.push(nodeQueueObject);
				t = t.left;
			}
			else
			{
				distance /= 2;
				length += distance;
				height++;
				if(t.right != null) nodeQueueObject.line = t.rightLine;
				if(t.right != null) nodeQueueObject.message = number + ' is greater than ' + t.data + ', so go right';
document.getElementById('removeFromBinaryTreeErrorSection').innerHTML =nodeQueueObject.message;
				highlightNodeQueue.push(nodeQueueObject);
				t = t.right;
			}
		}
		if(t == null)
		{
			alert("Invalid Input");
			document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = 'Invalid number';
			highlightForInsertion();
			return;
		}
		
		if(binarySearchTreeRoot == t)
		{
			found = 1;
nodeQueueObject.message = number + ' is deleted.';
document.getElementById('removeFromBinaryTreeErrorSection').innerHTML =nodeQueueObject.message;
		}
		else
		{
			if(j.left == t) found = 2;
			else found = 3;
		}
		if(t.left == null && t.right == null)
		{
			if(found == 1)
			{
				// binarySearchTreeRoot.element.remove();
				removeNode = binarySearchTreeRoot.element;
				binarySearchTreeRoot = null;
			}
			if(found == 2)
			{
				// j.leftLine.remove();
				// j.left.element.remove();
				removeLine = j.leftLine;
				removeNode = j.left.element;
				j.left = null;
			}
			if(found == 3)
			{
				// j.rightLine.remove();
				// j.right.element.remove();
				removeLine = j.rightLine;
				removeNode = j.right.element;
				j.right = null;
			}
		}
		else if(t.left == null)
		{
			if(found == 1)
			{
				// binarySearchTreeRoot.element.remove();
				removeLine = binarySearchTreeRoot.rightLine;
				removeNode = binarySearchTreeRoot.element;
				binarySearchTreeRoot = binarySearchTreeRoot.right;
			}
			if(found == 2)
			{
				// t.rightLine.remove();
				// j.left.element.remove();
				removeLine = t.rightLine;
				removeNode = j.left.element;
				j.left = t.right;
			}
			if(found == 3)
			{
				// t.rightLine.remove();
				// j.right.element.remove();
				removeLine = t.rightLine;
				removeNode = j.right.element;
				j.right = t.right;
			}
			let l = length;
			let d = distance;
			let h = height;
			distance /= 2;
			length += distance;
			height++;
			let animateNodeQueueObject = new AnimateNodeQueueObject(t.right);
			animateNodeQueueObject.oldDistance = distance;
			animateNodeQueueObject.newDistance = d;
			animateNodeQueueObject.oldX = length;
			animateNodeQueueObject.oldY = height * 80;
			animateNodeQueueObject.newX = l;
			animateNodeQueueObject.newY = h * 80;
			animateNodeQueue.push(animateNodeQueueObject);
			let e = 0;
			while(e < animateNodeQueue.length)
			{
				if(animateNodeQueue[e].node.left != null)
				{
					let dist = animateNodeQueue[e].oldDistance;
					let dis = animateNodeQueue[e].newDistance;
					dist /= 2;
					dis /= 2;
					let animateNodeQueueObject = new AnimateNodeQueueObject(animateNodeQueue[e].node.left);
					animateNodeQueueObject.oldDistance = dist;
					animateNodeQueueObject.newDistance = dis;
					animateNodeQueueObject.oldX = animateNodeQueue[e].oldX - dist;
					animateNodeQueueObject.oldY = animateNodeQueue[e].oldY + 80;
					animateNodeQueueObject.newX = animateNodeQueue[e].newX - dis;
					animateNodeQueueObject.newY = animateNodeQueue[e].newY + 80;;
					animateNodeQueue.push(animateNodeQueueObject);
					let animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
					animate.setAttribute('attributeName', 'd');
					animate.setAttribute('attributeType', 'XML');
					animate.setAttribute('dur', '1s');
					animate.setAttribute('repeatCount', '1');
					animate.setAttribute('from', 'M' + (animateNodeQueue[e].oldX + 20) + ' ' + (animateNodeQueue[e].oldY + 20) + ' L' + (animateNodeQueueObject.oldX + 20) + ' ' + (animateNodeQueueObject.oldY + 20));
					animate.setAttribute('to', 'M' + (animateNodeQueue[e].newX + 20) + ' ' + (animateNodeQueue[e].newY + 20) + ' L' + (animateNodeQueueObject.newX + 20) + ' ' + (animateNodeQueueObject.newY + 20));
					let animateLineQueueObject = new AnimateLineQueueObject(animateNodeQueue[e].node.leftLine, animate);
					animateLineQueue.push(animateLineQueueObject);
				}
				if(animateNodeQueue[e].node.right != null)
				{
					let dist = animateNodeQueue[e].oldDistance;
					let dis = animateNodeQueue[e].newDistance;
					dist /= 2;
					dis /= 2;
					let animateNodeQueueObject = new AnimateNodeQueueObject(animateNodeQueue[e].node.right);
					animateNodeQueueObject.oldDistance = dist;
					animateNodeQueueObject.newDistance = dis;
					animateNodeQueueObject.oldX = animateNodeQueue[e].oldX + dist;
					animateNodeQueueObject.oldY = animateNodeQueue[e].oldY + 80;
					animateNodeQueueObject.newX = animateNodeQueue[e].newX + dis;
					animateNodeQueueObject.newY = animateNodeQueue[e].newY + 80;;
					animateNodeQueue.push(animateNodeQueueObject);
					let animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
					animate.setAttribute('attributeName', 'd');
					animate.setAttribute('attributeType', 'XML');
					animate.setAttribute('dur', '1s');
					animate.setAttribute('repeatCount', '1');
					animate.setAttribute('from', 'M' + (animateNodeQueue[e].oldX + 20) + ' ' + (animateNodeQueue[e].oldY + 20) + ' L' + (animateNodeQueueObject.oldX + 20) + ' ' + (animateNodeQueueObject.oldY + 20));
					animate.setAttribute('to', 'M' + (animateNodeQueue[e].newX + 20) + ' ' + (animateNodeQueue[e].newY + 20) + ' L' + (animateNodeQueueObject.newX + 20) + ' ' + (animateNodeQueueObject.newY + 20));
					let animateLineQueueObject = new AnimateLineQueueObject(animateNodeQueue[e].node.rightLine, animate);
					animateLineQueue.push(animateLineQueueObject);
				}
				++e;
			}
		}
		else if(t.right == null)
		{
			if(found == 1)
			{
				// binarySearchTreeRoot.element.remove();
				removeLine = binarySearchTreeRoot.leftLine;
				removeNode = binarySearchTreeRoot.element;
				binarySearchTreeRoot = t.left;
			}
			if(found == 2)
			{
				// t.leftLine.remove();
				// j.left.element.remove();
				removeLine = t.leftLine;
				removeNode = j.left.element;
				j.left = t.left;
			}
			if(found == 3)
			{
				// t.leftLine.remove();
				// j.right.element.remove();
				removeLine = t.leftLine;
				removeNode = j.right.element;
				j.right = t.left;
			}
			let l = length;
			let d = distance;
			let h = height;
			distance /= 2;
			length -= distance;
			height++;
			let animateNodeQueueObject = new AnimateNodeQueueObject(t.left);
			animateNodeQueueObject.oldDistance = distance;
			animateNodeQueueObject.newDistance = d;
			animateNodeQueueObject.oldX = length;
			animateNodeQueueObject.oldY = height * 80;
			animateNodeQueueObject.newX = l;
			animateNodeQueueObject.newY = h * 80;
			animateNodeQueue.push(animateNodeQueueObject);
			let e = 0;
			while(e < animateNodeQueue.length)
			{
				if(animateNodeQueue[e].node.left != null)
				{
					let dist = animateNodeQueue[e].oldDistance;
					let dis = animateNodeQueue[e].newDistance;
					dist /= 2;
					dis /= 2;
					let animateNodeQueueObject = new AnimateNodeQueueObject(animateNodeQueue[e].node.left);
					animateNodeQueueObject.oldDistance = dist;
					animateNodeQueueObject.newDistance = dis;
					animateNodeQueueObject.oldX = animateNodeQueue[e].oldX - dist;
					animateNodeQueueObject.oldY = animateNodeQueue[e].oldY + 80;
					animateNodeQueueObject.newX = animateNodeQueue[e].newX - dis;
					animateNodeQueueObject.newY = animateNodeQueue[e].newY + 80;;
					animateNodeQueue.push(animateNodeQueueObject);
					let animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
					animate.setAttribute('attributeName', 'd');
					animate.setAttribute('attributeType', 'XML');
					animate.setAttribute('dur', '1s');
					animate.setAttribute('repeatCount', '1');
					animate.setAttribute('from', 'M' + (animateNodeQueue[e].oldX + 20) + ' ' + (animateNodeQueue[e].oldY + 20) + ' L' + (animateNodeQueueObject.oldX + 20) + ' ' + (animateNodeQueueObject.oldY + 20));
					animate.setAttribute('to', 'M' + (animateNodeQueue[e].newX + 20) + ' ' + (animateNodeQueue[e].newY + 20) + ' L' + (animateNodeQueueObject.newX + 20) + ' ' + (animateNodeQueueObject.newY + 20));
					let animateLineQueueObject = new AnimateLineQueueObject(animateNodeQueue[e].node.leftLine, animate);
					animateLineQueue.push(animateLineQueueObject);
				}
				if(animateNodeQueue[e].node.right != null)
				{
					let dist = animateNodeQueue[e].oldDistance;
					let dis = animateNodeQueue[e].newDistance;
					dist /= 2;
					dis /= 2;
					let animateNodeQueueObject = new AnimateNodeQueueObject(animateNodeQueue[e].node.right);
					animateNodeQueueObject.oldDistance = dist;
					animateNodeQueueObject.newDistance = dis;
					animateNodeQueueObject.oldX = animateNodeQueue[e].oldX + dist;
					animateNodeQueueObject.oldY = animateNodeQueue[e].oldY + 80;
					animateNodeQueueObject.newX = animateNodeQueue[e].newX + dis;
					animateNodeQueueObject.newY = animateNodeQueue[e].newY + 80;;
					animateNodeQueue.push(animateNodeQueueObject);
					let animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
					animate.setAttribute('attributeName', 'd');
					animate.setAttribute('attributeType', 'XML');
					animate.setAttribute('dur', '1s');
					animate.setAttribute('repeatCount', '1');
					animate.setAttribute('from', 'M' + (animateNodeQueue[e].oldX + 20) + ' ' + (animateNodeQueue[e].oldY + 20) + ' L' + (animateNodeQueueObject.oldX + 20) + ' ' + (animateNodeQueueObject.oldY + 20));
					animate.setAttribute('to', 'M' + (animateNodeQueue[e].newX + 20) + ' ' + (animateNodeQueue[e].newY + 20) + ' L' + (animateNodeQueueObject.newX + 20) + ' ' + (animateNodeQueueObject.newY + 20));
					let animateLineQueueObject = new AnimateLineQueueObject(animateNodeQueue[e].node.rightLine, animate);
					animateLineQueue.push(animateLineQueueObject);
				}
				++e;
			}
		}
		else
		{
			// done done
			let d = distance;
			let l = length;
			let h = height;
			distance /= 2;
			length += distance;
			height++;
			let f = t.right;
			let e = null;
			while(f.left != null)
			{
				distance /= 2;
				length -= distance;
				height++;
				e = f;
				f = f.left;
			}
			if(found == 1)
			{
			//document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = number + ' is deleted';
				if(f == t.right) removeLine = t.rightLine;
				else
				{
					if(f.right != null) removeLine = f.rightLine;
					else removeLine = e.leftLine;
				}
				removeNode = binarySearchTreeRoot.element;
				binarySearchTreeRoot = f;
			}
			if(found == 2)
			{
				if(f == t.right) removeLine = t.rightLine;
				else
				{
					if(f.right != null) removeLine = f.rightLine;
					else removeLine = e.leftLine;
				}
				removeNode = j.left.element;
				j.left = f;
			}
			if(found == 3)
			{
				if(f == t.right) removeLine = t.rightLine;
				else
				{
					if(f.right != null) removeLine = f.rightLine;
					else removeLine = e.leftLine;
				}
				removeNode = j.right.element;
				j.right = f;
			}
			let animateNodeQueueObject = new AnimateNodeQueueObject(f);
			animateNodeQueueObject.oldDistance = distance;
			animateNodeQueueObject.newDistance = d;
			animateNodeQueueObject.oldX = length;
			animateNodeQueueObject.oldY = height * 80;
			animateNodeQueueObject.newX = l;
			animateNodeQueueObject.newY = h * 80;
			animateNodeQueue.push(animateNodeQueueObject);
			l = length;
			d = distance;
			h = height;
			distance /= 2;
			length += distance;
			height++;
			if(f.right != null)
			{
				animateNodeQueueObject = new AnimateNodeQueueObject(f.right);
				animateNodeQueueObject.oldDistance = distance;
				animateNodeQueueObject.newDistance = d;
				animateNodeQueueObject.oldX = length;
				animateNodeQueueObject.oldY = height * 80;
				animateNodeQueueObject.newX = l;
				animateNodeQueueObject.newY = h * 80;
				animateNodeQueue.push(animateNodeQueueObject);
				let animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
				animate.setAttribute('attributeName', 'd');
				animate.setAttribute('attributeType', 'XML');
				animate.setAttribute('dur', '1s');
				animate.setAttribute('repeatCount', '1');
				animate.setAttribute('from', 'M' + (animateNodeQueue[0].oldX + 20) + ' ' + (animateNodeQueue[0].oldY + 20) + ' L' + (animateNodeQueueObject.oldX + 20) + ' ' + (animateNodeQueueObject.oldY + 20));
				animate.setAttribute('to', 'M' + (animateNodeQueue[0].newX + 20) + ' ' + (animateNodeQueue[0].newY + 20) + ' L' + (animateNodeQueueObject.newX + 20) + ' ' + (animateNodeQueueObject.newY + 20));
				// animate.setAttribute('values', 'M' + (animateNodeQueue[0].oldX + 20) + ' ' + (animateNodeQueue[0].oldY + 20) + ' L' + (animateNodeQueueObject.oldX + 20) + ' ' + (animateNodeQueueObject.oldY + 20) + ';' + 'M' + (animateNodeQueue[0].newX + 20) + ' ' + (animateNodeQueue[0].newY + 20) + ' L' + (animateNodeQueueObject.newX + 20) + ' ' + (animateNodeQueueObject.newY + 20));
				// animate.setAttribute('keyTimes', '0 ; 2');
				let animateLineQueueObject = new AnimateLineQueueObject(animateNodeQueue[0].node.rightLine, animate);
				animateLineQueue.push(animateLineQueueObject);
			}
			let i = 1;
			while(i < animateNodeQueue.length)
			{
				if(animateNodeQueue[i].node.left != null)
				{
					let dist = animateNodeQueue[i].oldDistance;
					let dis = animateNodeQueue[i].newDistance;
					dist /= 2;
					dis /= 2;
					let animateNodeQueueObject = new AnimateNodeQueueObject(animateNodeQueue[i].node.left);
					animateNodeQueueObject.oldDistance = dist;
					animateNodeQueueObject.newDistance = dis;
					animateNodeQueueObject.oldX = animateNodeQueue[i].oldX - dist;
					animateNodeQueueObject.oldY = animateNodeQueue[i].oldY + 80;
					animateNodeQueueObject.newX = animateNodeQueue[i].newX - dis;
					animateNodeQueueObject.newY = animateNodeQueue[i].newY + 80;;
					animateNodeQueue.push(animateNodeQueueObject);
					let animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
					animate.setAttribute('attributeName', 'd');
					animate.setAttribute('attributeType', 'XML');
					animate.setAttribute('dur', '1s');
					animate.setAttribute('repeatCount', '1');
					animate.setAttribute('from', 'M' + (animateNodeQueue[i].oldX + 20) + ' ' + (animateNodeQueue[i].oldY + 20) + ' L' + (animateNodeQueueObject.oldX + 20) + ' ' + (animateNodeQueueObject.oldY + 20));
					animate.setAttribute('to', 'M' + (animateNodeQueue[i].newX + 20) + ' ' + (animateNodeQueue[i].newY + 20) + ' L' + (animateNodeQueueObject.newX + 20) + ' ' + (animateNodeQueueObject.newY + 20));
					let animateLineQueueObject = new AnimateLineQueueObject(animateNodeQueue[i].node.leftLine, animate);
					animateLineQueue.push(animateLineQueueObject);

				}
				if(animateNodeQueue[i].node.right != null)
				{
					let dist = animateNodeQueue[i].oldDistance;
					let dis = animateNodeQueue[i].newDistance;
					dist /= 2;
					dis /= 2;
					let animateNodeQueueObject = new AnimateNodeQueueObject(animateNodeQueue[i].node.right);
					animateNodeQueueObject.oldDistance = dist;
					animateNodeQueueObject.newDistance = dis;
					animateNodeQueueObject.oldX = animateNodeQueue[i].oldX + dist;
					animateNodeQueueObject.oldY = animateNodeQueue[i].oldY + 80;
					animateNodeQueueObject.newX = animateNodeQueue[i].newX + dis;
					animateNodeQueueObject.newY = animateNodeQueue[i].newY + 80;;
					animateNodeQueue.push(animateNodeQueueObject);
					let animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
					animate.setAttribute('attributeName', 'd');
					animate.setAttribute('attributeType', 'XML');
					animate.setAttribute('dur', '1s');
					animate.setAttribute('repeatCount', '1');
					animate.setAttribute('from', 'M' + (animateNodeQueue[i].oldX + 20) + ' ' + (animateNodeQueue[i].oldY + 20) + ' L' + (animateNodeQueueObject.oldX + 20) + ' ' + (animateNodeQueueObject.oldY + 20));
					animate.setAttribute('to', 'M' + (animateNodeQueue[i].newX + 20) + ' ' + (animateNodeQueue[i].newY + 20) + ' L' + (animateNodeQueueObject.newX + 20) + ' ' + (animateNodeQueueObject.newY + 20));
					let animateLineQueueObject = new AnimateLineQueueObject(animateNodeQueue[i].node.rightLine, animate);
					animateLineQueue.push(animateLineQueueObject);
				}
				++i;
			}
			if(f == t.right)
			{
				f.left = t.left;
				f.leftLine = t.leftLine;
			}
			else
			{
				e.left = f.right;
				// e.leftLine = f.rightLine;
				f.right = t.right;
				f.rightLine = t.rightLine;
				f.left = t.left;
				f.leftLine = t.leftLine;
			}
			// done done
			//document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = number + ' is deleted';
		}
nodeQueueObject.message = number + ' is deleted.';
document.getElementById('removeFromBinaryTreeErrorSection').innerHTML =nodeQueueObject.message;
		highlightForDeletion();

	}
	function highlightForDeletion()
	{
		if(g)
		{
			// alert("** " + nodeQueue[0],node + " ** " + nodeQueue.length);
			highlightNodeQueue[0].node.removeEventListener('animationend', highlightForDeletion);
			highlightNodeQueue[0].node.classList.remove('highlightNode');
			if(highlightNodeQueue[0].line != null) highlightNodeQueue[0].line.classList.remove('highlightLine');
			highlightNodeQueue.splice(0, 1);
		}
		g = true;
		if(highlightNodeQueue.length == 0)
		{
			rearrangeNode();
			g = false;
			return;
		}
		// alert(nodeQueue[0].node.classList);
		highlightNodeQueue[0].node.classList.add('highlightNode');
		if(highlightNodeQueue[0].line != null) highlightNodeQueue[0].line.classList.add('highlightLine');
		document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = highlightNodeQueue[0].message;
		// alert(nodeQueue[0].node.classList);
		highlightNodeQueue[0].node.addEventListener('animationend', highlightForDeletion, false);
	}
	function rearrangeNode()
	{
		// alert(removeLine);
		if(removeLine != null) removeLine.remove();
		if(removeNode != null) removeNode.remove();
		let e = 0;
		while(e < animateNodeQueue.length)
		{
			let x = animateNodeQueue[e];
			x.node.element.classList.add('rearrange');
			// $('.rearrange:nth-of-type(' + (e + 1) + ')').css('--oldX', ' ' + x.oldX);
			// $('.rearrange:nth-of-type(' + (e + 1) + ')').css('--oldY', ' ' + x.oldY);
			// $('.rearrange:nth-of-type(' + (e + 1) + ')').css('--newX', ' ' + x.newX);
			// $('.rearrange:nth-of-type(' + (e + 1) + ')').css('--newY', ' ' + x.newY);
			x.node.element.style.setProperty('--oldX', ' ' + x.oldX);
			x.node.element.style.setProperty('--oldY', ' ' + x.oldY);
			x.node.element.style.setProperty('--newX', ' ' + x.newX);
			x.node.element.style.setProperty('--newY', ' ' + x.newY);
			x.node.element.style.setProperty('transform', 'translate(' + x.newX + 'px, ' + x.newY + 'px)')
			// alert($('.rearrange:nth-of-type(' + (e + 1) + ')').css('--oldY'));
		// alert(document.getElementsByClassName('rearrange').length + ' -- ' + document.getElementsByClassName('rearrange')[0].id + ' -- ' + document.documentElement.style.getPropertyValue('--oldX') + ' -- ' + x.oldX + ' -- ' + x.oldY + ' -- ' + x.newX + ' -- ' + x.newY + ' -- ' + x.node.element.innerHTML);
			++e;
		}
		if(e > 0) animateNodeQueue[e - 1].node.element.addEventListener('animationend', afterRearrange, false);
		else 
ena();
		e = 0;
		while(e < animateLineQueue.length)
		{
			animateLineQueue[e].line.append(animateLineQueue[e].animate);
			animateLineQueue[e].animate.beginElement();
			animateLineQueue[e].line.setAttribute('d', animateLineQueue[e].animate.getAttribute('to'));
			++e;
		}
		removeLine = null;
		removeNode = null;
	}
	function afterRearrange()
	{
		let e = 0;
		while(e < animateNodeQueue.length)
		{
			animateNodeQueue[e].node.element.classList.remove('rearrange');
			++e;
		}
		if(e > 0) animateNodeQueue[e - 1].node.element.removeEventListener('animationend', afterRearrange);
		animateNodeQueue.splice(0, animateNodeQueue.length);
		e = 0;
		while(e < animateLineQueue.length)
		{
			$('#' + animateLineQueue[e].line.id).empty();
			++e;
		}

		animateLineQueue.splice(0, animateLineQueue.length);
		ena();
	}
	function emptyBinaryTree()
	{
		$('#heading').html("BINARY SEARCH TREE");
		$("#tc").html("");
		if(binarySearchTreeRoot == null)
		{
			alert("Binary Search Tree is ALREADY EMPTY!!");
			document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = 'Binary Search Tree is already empty';
			return;
		}
		// alert('empty');
document.getElementById('removeFromBinaryTreeErrorSection').innerHTML = 'Binary Search Tree is empty.';
		binarySearchTreeRoot = null;
		$('#binarySearchTreeView').empty();
		$('#svg').empty();
	}

 </script>

  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>

<script>
window.addEventListener("load",hideArea);
</script>
<style>
body {
  font-family: "Lato", sans-serif;
}

#removeFromBinaryTreeErrorSection
{
position:absolute;
 right: 2px; 
top:0;
display:flex;
align-items:center;
justify-content:center;
color:white;
    margin: 0px;
width: 280px;
    height: 225px;
 background-image: url("msg.jpg");
padding:30px;
}
#addToBinaryTreeErrorSection
{
position:absolute;
 right: 2px; 
top:0;
display:flex;
align-items:center;
justify-content:center;
color:white;
    margin: 0px;
width: 280px;
    height: 225px;
 background-image: url("msg.jpg");
padding:30px;
}

#creation {
    position:fixed;
    top: 50%;
    left: 40%;
    width:33em;
    height:4em;
    margin-top: -9em; /*set to a negative number 1/2 of your height*/
    margin-left: -15em; /*set to a negative number 1/2 of your width*/
    display: inline-block;
 
}
.sidenav {
  height: 100%;
  width: 230px;
  position: fixed;
  z-index: 1;
  top: 0;
  left: 0;
  background-color: #111;
  overflow-x: hidden;
  padding-top: 20px;
}

.sidenav a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 25px;
  color: white;
  display: block;
}

.sidenav a:hover {
  color: white;
}

.main {
	overflow: auto;
  margin-left: 230px; /* Same as the width of the sidenav */
  font-size: 28px; /* Increased text to enable scrolling */
  padding: 0px 10px;

}

.sidenav a:hover {
 font-size: 30px;
}



.btn {
  background-color: Grey;
  border: none;
  color: white;
  padding: 12px 16px;
  font-size: 16px;
  cursor: pointer;
height:45px;
}

.btn:hover {
  background-color: RoyalBlue;
}





:root {
		--oldX: 100px;
		--oldY: 100px;
		--newX: 400px;
		--newY: 350px;
	}


/*binary serch tree animation starts here*/
	.highlightNode {
		animation-name: highlight-node;
		animation-duration: 1s;
		animation-direction: all;
		animation-iteration-count: initial;
	}
	@keyframes highlight-node {
		0% {
			background: #ff4000;
			border: 3px solid black;
			color: white;
		}
		50% {
			background: #ff4000;
			border: 3px solid black;
			color: white;
		}
		100% {
			background: #ff4000;
			border: 3px solid black;
			color: white;
		}
	}
	.highlightLine {
		animation-name: highlight-line;
		animation-duration: 1s;
		animation-direction: all;
		animation-iteration-count: initial;
	}
	@keyframes highlight-line {
		0% {
			stroke: #ff4000;
			stroke-width: 3;
		}
		50% {
			stroke: #ff4000;
			stroke-width: 10;
		}
		100% {
			stroke: #ff4000;
			stroke-width: 3;
		}
	}
	.animateLine {
		animation-name: addLine;
		animation-duration: 0.8s;
		animation-direction: all;
		animation-iteration-count: initial;
	}
	@keyframes addLine {
		from {
			stroke-dashoffset: 500;
			stroke: #ff4000;
			stroke-width: 10;
		}
		to {
			stroke-dashoffset: 0;
			stroke: #ff4000;
			stroke-width: 3;
		}
	}
	.rearrange {
		animation-name: rearrangeNode;
		animation-duration: 1s;
		animation-direction: all;
		animation-iteration-count: initial;
		animation-timing-function: linear;
	}
	@keyframes rearrangeNode {
		from {
			transform: translate(calc(var(--oldX) * 1px), calc(var(--oldY) * 1px));
		}
		to {
			transform: translate(calc(var(--newX) * 1px), calc(var(--newY) * 1px));
		}
	}
	/*binary serch tree animation ends here*/









@media screen and (max-height: 450px) {
  .sidenav {padding-top: 15px;}
  .sidenav a {font-size: 18px;}
}
</style>
</head>
<body>

<div class="sidenav">
<a href="./index.html"><button class="btn"> Home</button></a>
<h1 style="color:white; margin: 10px;">BINARY SEARCH TREE</h1>
  <a href="#insertionModal" id='insertionFunction' data-toggle="modal" onclick="insertModal()">INSERTION</a>
  <a href="#deletionModal" id='deletionFunction' data-toggle="modal" onclick="deleteModal()">DELETION</a>
  <a href="#" id = 'emptyBinarySearchTreeButton' onclick = 'javascript: emptyBinaryTree()'> EMPTY</a>
  
</div>
<div class="main" >
  
<H1 id="heading">BINARY SEARCH TREE</H1> 
<b><div id = 'addToBinaryTreeErrorSection' style="color:black"></div>
<div id = 'removeFromBinaryTreeErrorSection' style="color:black"></div></b>
<H3 id='tc'></H3>

<div class="container" id="creation" >
<div id = 'binarySearchTreeView'></div>
	<svg id = 'svg' width = '1350' height = '500'></svg></div>

</div>

<div class="modal fade" id="insertionModal" tabindex="-1" role="dialog" aria-labelledby="insertionModalLabel"
  aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="insertionModalLabel">INSERTION</h5>
       <button type="button" class="close" data-dismiss="modal" aria-label="close">&times; </button>
      </div>
      <div class="modal-body">
<small>Enter an element to be inserted in Tree:</small>	
<input type="number" class="form-control" id="binaryTreeValue" name="binaryTreeValue" placeholder="ENTER ELEMENT">
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" id = 'insertToBinarySearchTreeButton' data-dismiss="modal" onclick="insertToBinarySearchTree()">INSERT</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="deletionModal" tabindex="-1" role="dialog" aria-labelledby="deletionModalLabel"
  aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="deletionModalLabel">DELETION</h5>
       <button type="button" class="close" data-dismiss="modal" aria-label="close">&times; </button>
      </div>
      <div class="modal-body">
	<small>Enter Number to be Deleted:</small>
          <input type="number" class="form-control" id="removeValue" name="removeValue" placeholder="ENTER ELEMENT">

      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
        <button type="button" id = 'removeFromBinarySearchTreeButton' class="btn btn-primary" data-dismiss="modal" onclick="removeFromBinarySearchTree()">DELETE</button>
      </div>
    </div>
  </div>
</div>






